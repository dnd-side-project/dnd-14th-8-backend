# 세션 정리 — 2026-02-16 참여자 조회·투표 리팩토링

## 1. MultipleBagFetchException

### 문제
`ParticipantRepository.findByMeetingIdAndLocalStorageKey()` 쿼리에서 `List` 타입 컬렉션 2개(`scheduleVotes`, `locationVotes`)를 동시에 `LEFT JOIN FETCH`하여 `MultipleBagFetchException` 발생.

```java
// 문제 코드
@Query("SELECT p FROM Participant p " +
        "LEFT JOIN FETCH p.scheduleVotes " +
        "LEFT JOIN FETCH p.locationVotes " +   // ← List 2개 동시 fetch
        "WHERE p.meeting.id = :meetingId AND p.localStorageKey = :localStorageKey")
```

### 원인
Hibernate는 `List`(Bag 시맨틱) 컬렉션을 2개 이상 동시에 JOIN FETCH하면 **카테시안 곱**이 발생하여 어떤 row가 어떤 컬렉션에 속하는지 구분할 수 없다.

### 해결 방법 3가지
| 방법 | 쿼리 수 | 트레이드오프 |
|------|---------|------------|
| `List` → `Set` 변경 | 1개 | 순서 보장 불가 |
| JOIN FETCH 1개만 + `@BatchSize` | 2개 (1+1) | 단건 조회라 성능 차이 미미 |
| 쿼리 2개로 분리 | 2개 | 명시적이나 코드 복잡도 증가 |

### 인사이트
- `@BatchSize`가 이미 걸려있어도 JOIN FETCH와 역할이 다르다. `@BatchSize`는 lazy loading 시점에 IN 절로 묶어주는 것이고, JOIN FETCH는 한 쿼리에서 즉시 로딩하는 것.
- 단건 조회에서 쿼리 1+1은 N+1과 본질적으로 다르다. 성능 최적화의 우선순위를 올바르게 판단해야 한다.

---

## 2. REST 엔드포인트 설계 — `/me` 패턴

### 배경
프론트에서 모임 링크로 입장 시 `meetingId + localStorageKey`는 알지만 `participantId`(PK)는 모르는 상태. 본인 정보를 조회할 엔드포인트가 필요.

### 설계 결정
```
GET /api/participants/me?meetingId={meetingId}&localStorageKey={localStorageKey}
```

### `/me`를 붙여야 하는 이유
`/me` 없이 query param으로만 분기하면:
- `GET /api/participants?meetingId=xxx` (목록) vs `GET /api/participants?meetingId=xxx&localStorageKey=xxx` (단건)
- 같은 경로에서 query param 유무로 동작이 갈림 → 컨트롤러 매핑 애매, Swagger 문서 구분 불가

`/me`를 붙이면 세 엔드포인트가 경로 수준에서 깔끔하게 분리:
- `GET /api/participants` → 목록
- `GET /api/participants/me` → 본인 단건 (meetingId + localStorageKey)
- `GET /api/participants/{id}` → PK 단건 (필요 시)

### 인사이트
- `/me`는 "현재 사용자 본인"을 나타내는 REST 관례. 인증 없이 localStorageKey로 식별하는 프로젝트에서도 의미가 통한다.
- `localStorageKey`는 URL path에 넣기엔 길고 민감할 수 있으므로 query param이 적절.

---

## 3. JPA cascade persist와 객체 참조 — ID 반환 메커니즘

### 문제
`createParticipantVote()`에서 생성한 `ScheduleVote`의 ID를 반환하고 싶은데, `ScheduleVote.of()`로 만든 plain Java 객체일 뿐인데 어떻게 ID를 가져올 수 있는가?

### 핵심 메커니즘

```java
// 1. plain Java 객체 (id = null)
ScheduleVote scheduleVote = ScheduleVote.of(schedulePoll, votedDates);

// 2. participant 내부 리스트에 추가 (같은 힙 메모리 객체 참조)
Participant participant = Participant.of(..., scheduleVote);

// 3. save → cascade persist → IDENTITY 전략이므로 즉시 INSERT
participantService.save(participant);

// 4. DB가 생성한 ID가 기존 객체의 id 필드에 리플렉션으로 세팅됨
return scheduleVote.getId();  // → NOT null
```

**Hibernate가 새 객체를 만드는 게 아니다.** 내가 만든 그 객체 자체를 영속성 컨텍스트에 등록하고, 그 객체의 `id` 필드에 리플렉션으로 값을 넣어준다.

```
[힙 메모리]
scheduleVote 변수 ──┐
                     ├──→ ScheduleVote@0x1234 { id: null → 7 }
participant.scheduleVotes[0] ──┘
```

### `meeting.addParticipant()` vs `participantService.save()`

| 방식 | persist 시점 | ID 사용 가능 시점 |
|------|-------------|-----------------|
| `meeting.addParticipant()` | flush 시점 (트랜잭션 커밋) | 메서드 리턴 후 |
| `participantService.save()` | **즉시** (IDENTITY 전략) | save() 호출 직후 |

`meeting.addParticipant()`는 컬렉션에 추가만 하고 cascade persist는 flush까지 지연된다. IDENTITY 전략이라 INSERT 자체는 persist 시점에 바로 나가지만, cascade 자체가 flush까지 지연되므로 메서드 리턴 시점에 ID가 없을 수 있다.

### IDENTITY vs SEQUENCE 전략 차이
- **IDENTITY**: INSERT 없이는 ID를 알 수 없으므로 `persist()` 시점에 항상 즉시 INSERT 실행
- **SEQUENCE**: `persist()` 시점에 시퀀스만 조회하고 INSERT는 flush까지 지연 가능

### 인사이트
- JPA에서 "객체를 저장한다"는 것은 새 객체를 만드는 게 아니라, 기존 객체를 영속성 컨텍스트에 등록하는 것이다. Java의 참조 시맨틱 덕분에 어디서든 같은 객체에 접근하면 변경된 상태를 볼 수 있다.
- `save()` 직접 호출은 cascade 의존을 끊고 persist 시점을 명시적으로 제어할 수 있다. ID 반환이 필요한 경우 이 방식이 적합하다.

---

## 4. 투표 확정 API 설계 — 동사형 경로

### 설계 결정
```
PUT /api/schedules/poll/{schedulePollId}/confirm
```

### PUT vs PATCH
- 실무에서 PUT/PATCH 구분을 엄격히 지키는 프로젝트는 드물다.
- 프로젝트 내 기존 컨벤션(`PUT /api/schedules/poll` — 부분 수정인데 PUT 사용)과 일관성을 맞추는 게 더 중요하다.
- **컨벤션 일관성 > HTTP 스펙 엄밀성**

---

## 5. 리팩토링 시 단위테스트 mock 대상 불일치 문제

### 문제
`SchedulePollServiceImpl`이 `MeetingService.get()` 대신 `MeetingRepository.findByIdWithAllAssociations()`를 직접 호출하도록 변경되었는데, 단위테스트의 mock 대상이 `MeetingService`로 남아있어 CI에서 3개 테스트 실패.

### 증상별 원인
- **NPE** (49라인): `meetingRepository`가 mock되지 않아 null → `findByIdWithAllAssociations()` 호출 시 NPE
- **AssertionError** (73, 95라인): meeting을 못 가져와서 `MEETING_NOT_FOUND` 예외가 나지만, 테스트는 `INVALID_FORMAT`을 기대

### 인사이트
- 서비스 레이어의 의존성을 변경하면 반드시 해당 서비스의 단위테스트 mock 대상도 함께 변경해야 한다.
- CI에서만 실패하고 로컬에서 통과하는 경우, 테스트 실행 범위가 다를 수 있으므로 PR 전 전체 테스트를 반드시 돌려야 한다.
