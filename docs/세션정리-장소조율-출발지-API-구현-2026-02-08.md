# 세션 정리 — 장소 조율 출발지 API 구현기

## 0. 배경

모임(Meeting) 하위에 장소 투표(LocationPoll), 그 아래 출발지(LocationVote)가 있는 구조에서 **출발지 CRUD API**를 구현해야 했다. 이미 엔티티 간 `CascadeType.ALL`이 걸려있는 상태에서, "Cascade를 어떻게 활용할 것인가"가 이번 세션의 출발점이었다.

---

## 1. Cascade로 하위 데이터를 추가할 수 있을까?

세션의 첫 질문은 단순했다. "Meeting과 함께 초기 생성된 이후, 변경감지로 하위 테이블에 데이터를 추가하려면 어떻게 해야 하나?"

답은 간단했다. **영속 상태의 부모 엔티티 컬렉션에 자식을 add하면, 트랜잭션 커밋 시점에 dirty checking + cascade로 자동 INSERT된다.** 별도 `save()` 호출 불필요.

```java
Meeting meeting = meetingRepository.findById(meetingId).orElseThrow();
meeting.addParticipant(Participant.of(meeting, name, null));
// 트랜잭션 커밋 시 자동 INSERT
```

여기까지는 교과서적인 내용이었다. 하지만 이후 실제 구현에 들어가면서 **Cascade에 대한 잘못된 가정**이 하나씩 드러나기 시작했다.

---

## 2. 확정 장소 저장 방식 — 설계 결정이 바뀌는 과정

### 처음: @Embeddable로 충분하다고 판단

LocationPoll에 확정 장소를 최대 3개 저장해야 했다. 처음엔 기존의 단일 필드(`confirmedLocation`, `confirmedLat`, `confirmedLng`)를 List로 바꾸는 것이 목적이었다.

`@Embeddable` + `@ElementCollection`을 선택했다. 이유는:
- 최대 3개로 고정
- 독립 조회 필요 없음
- LocationPoll 삭제 시 함께 삭제되어야 하는 값 객체 성격

```java
@ElementCollection
@CollectionTable(name = "confirmed_location", joinColumns = @JoinColumn(name = "location_poll_id"))
private List<ConfirmedLocation> confirmedLocations = new ArrayList<>();
```

그런데 여기서 의문이 생겼다. **"@Entity를 안 붙여도 DB에 테이블이 만들어지는 거야?"**

맞다. `@ElementCollection`도 별도 테이블을 생성한다. 차이는 테이블 유무가 아니라 **JPA가 독립 엔티티로 관리하느냐** 여부다.

| 기준 | `@Embeddable` | `@Entity` |
|------|--------------|-----------|
| 자체 PK (`@Id`) | X | O |
| Repository / 단독 CRUD | X | O |
| 영속성 컨텍스트 관리 / 변경감지 | **X** (전체 삭제→재삽입) | O (개별 UPDATE) |

### 전환: 요구사항을 더 파고들었더니

"확정 장소가 자주 바뀌어. 2명이 투표하면 강남역/홍대/왕십리인데, 3명이 투표하면 강남역/홍대/사당으로 바뀌고, 4명이면 또 달라지고..."

이 말을 듣고 판단이 바뀌었다. `@Embeddable`이면 투표할 때마다 **3 DELETE + 3 INSERT = 6쿼리**, `@Entity`면 **3 UPDATE = 3쿼리**. 투표 인원이 늘어날수록 이 로직이 반복 호출되니 차이가 누적된다.

**교훈: 초기 설계 시 "데이터가 얼마나 자주 변경되는가"를 반드시 확인해야 한다. 같은 "최대 3개"라도 변경 빈도에 따라 최적의 선택이 달라진다.**

---

## 3. 3시간의 고민 — 그리고 단순한 답

### 막혔던 지점

출발지 추가 API를 구현하는데 3시간을 고민만 하고 있었다. 원인은 **"Meeting을 통해서 모든 것을 해야 한다"는 사고에 갇혀있었기 때문**이다.

기존 코드가 Meeting을 조회하고 → JOIN FETCH로 연관 엔티티를 전부 끌고 오고 → DTO로 변환하는 패턴이었기에, 새 기능도 같은 패턴을 따라야 한다고 생각했다.

```java
// 기존 패턴 — Meeting을 중심으로 전체 조회
FindMeetingLocationResponse response = meetingService.findByIdWithLocation(meetingId);
// Meeting + LocationPoll + Participants 전부 JOIN FETCH
```

### 깨달음

출발지 추가에 진짜 필요한 건 **LocationPoll 하나뿐**이었다. Meeting 전체를 끌고 올 이유가 없었다.

```java
// 단순한 해결
LocationPoll locationPoll = locationPollRepository.findByMeeting_MeetingId(meetingId);
LocationVote vote = LocationVote.of(locationPoll, ...);
locationVoteRepository.save(vote);
```

하지만 여기서 한 단계 더 나아갔다.

### `ofId()` 패턴의 발견

"LocationPoll을 조회하지 않고, ID만으로 FK를 세팅할 수는 없을까?"

JPA에는 `getReferenceById()`가 있다. SELECT 쿼리 없이 프록시 객체를 반환해서 FK 세팅에 쓸 수 있다.

```java
// 방법 1: findById() — SELECT 쿼리 발생, 전체 데이터 조회
LocationPoll poll = locationPollRepository.findById(id).orElseThrow();

// 방법 2: getReferenceById() — SELECT 없음, 프록시 객체
LocationPoll poll = locationPollRepository.getReferenceById(id);
// ID만 가진 껍데기. poll.getPollStatus() 같은 접근 시 그때 SELECT 발생 (LAZY)
```

하지만 둘 다 **Repository 의존성이 필요**하다. 여기서 `ofId()` 패턴이 나왔다.

```java
// 방법 3: ofId() — SELECT 없음, Repository도 불필요
public static LocationPoll ofId(Long locationPollId) {
    return LocationPoll.builder()
            .locationPollId(locationPollId)
            .build();
}
```

세 가지 비교:

| 방식 | SELECT 쿼리 | Repository 필요 | 영속성 컨텍스트 | 연관 탐색 |
|------|------------|----------------|---------------|----------|
| `findById()` | O | O | 영속 상태 | O |
| `getReferenceById()` | X (접근 시 발생) | O | 프록시 | O (LAZY) |
| `ofId()` | X | **X** | detached | **X** |

`ofId()`를 쓰면 팩토리 메서드 안에서 변환 로직이 완결된다.

```java
// LocationVote 팩토리 메서드 안에서 LocationPoll FK 세팅까지 완결
public static LocationVote fromByCreateLocationVoteRequest(CreateLocationVoteRequest request) {
    return LocationVote.builder()
            .locationPoll(LocationPoll.ofId(Long.parseLong(request.locationPollId())))
            .departureName(request.participantName())
            .departureLocation(request.departureLocation())
            .departureLat(new BigDecimal(request.departureLat()))
            .departureLng(new BigDecimal(request.departureLng()))
            .build();
}

// 서비스 코드가 한 줄로 끝남
locationVoteRepository.save(LocationVote.fromByCreateLocationVoteRequest(request));
```

**주의점**: `ofId()` 객체는 영속성 컨텍스트에 관리되지 않는 detached 상태. INSERT 시 FK 세팅 용도로만 써야 하고, 이 객체를 통해 `locationPoll.getLocationVotes()` 같은 연관 탐색은 불가.

**교훈: "엔티티 객체는 Repository를 통해 얻어야 한다"는 고정관념에서 벗어나면 코드가 훨씬 간결해진다. 하지만 용도(FK 세팅 전용)를 명확히 인지해야 한다.**

---

## 4. 이번 세션 최대의 교훈 — Cascade ≠ FK 세팅

### 버그 발견 과정

통합테스트를 작성하면서 발견했다. Participant를 저장할 때 Cascade로 LocationVote도 함께 INSERT는 되지만, **`participant_id` FK가 null**로 들어가는 현상.

```java
// Participant.of() — 컬렉션에 add만 함
public static Participant of(Meeting meeting, String key, String name, LocationVote vote) {
    Participant participant = Participant.of(meeting, key, name);
    participant.getLocationVotes().add(vote);  // inverse side에만 add
    return participant;
}

// participantService.save(participant) 실행 시:
// Participant INSERT ✅
// LocationVote INSERT ✅ (Cascade 동작)
// LocationVote.participant_id = NULL ❌ (owning side가 세팅 안 됨)
```

### 왜 이런 일이?

**Cascade와 FK 세팅은 완전히 별개의 메커니즘이다.**

- `CascadeType.ALL` → persist/merge/remove **연산을 전파** (INSERT는 해줌)
- FK 세팅 → **owning side 필드의 값**에 의존 (`LocationVote.participant`)

`@OneToMany(mappedBy = "participant")`에서 `mappedBy`는 "나(Participant)는 FK를 관리하지 않겠다"는 선언. Hibernate가 "Participant 컬렉션에 있으니까 FK를 알아서 넣어줘야지"라고 하지 않는다.

### 해결

owning side를 세팅하는 편의 메서드를 추가했다.

```java
// LocationVote.java
public void assignParticipant(Participant participant) {
    this.participant = participant;
}

// Participant.of() 수정
public static Participant of(Meeting meeting, String key, String name, LocationVote vote) {
    Participant participant = Participant.of(meeting, key, name);
    vote.assignParticipant(participant);  // owning side FK 세팅
    participant.getLocationVotes().add(vote);  // inverse side 동기화
    return participant;
}
```

이건 "양방향 연관관계를 만드는 것"이 아니라, **owning side의 FK를 세팅하는 연관관계 편의 메서드**다. 이거 없으면 Cascade로 저장은 되지만 `participant_id`가 항상 null이다.

**교훈: 통합테스트에서 flush → clear → 재조회로 실제 DB 상태를 확인하지 않았다면 이 버그를 절대 발견하지 못했다. 영속성 컨텍스트 캐시가 마스킹하는 버그에 주의.**

---

## 5. 테스트에서 얻은 교훈들

### 5-1. native INSERT 쿼리와 BaseEntity — CI 실패의 원인

PR을 올렸는데 CI에서 실패. 로컬에서는 통과하는데 CI에서만 깨졌다.

원인: 기존 `MeetingServiceIntegrationTest`에서 native INSERT로 테스트 데이터를 넣고 있었는데, `ScheduleVote`가 `BaseEntity`를 상속받으면서 `created_at`, `updated_at` NOT NULL 컬럼이 추가됨. JPA Auditing(`@CreatedDate`)은 native 쿼리에서 동작하지 않는다.

```sql
-- 실패: BaseEntity 컬럼 누락
INSERT INTO schedule_vote (participant_id, schedule_poll_id, voted_date) VALUES (?, ?, ?)

-- 수정: created_at, updated_at 포함
INSERT INTO schedule_vote (..., created_at, updated_at) VALUES (..., ?, ?)
```

**교훈: 엔티티 상속 구조가 바뀌면 native 쿼리도 함께 점검해야 한다. `@CreatedDate`/`@LastModifiedDate`는 JPA를 통한 persist에서만 동작하고, native 쿼리에서는 수동으로 값을 넣어야 한다.**

### 5-2. 조건 반전 — 유틸 메서드 교체의 함정

`StringUtil.isNullOrEmpty()` → `StringUtils.hasText()`로 변경하면서 분기 로직이 반전됐다.

```java
// isNullOrEmpty: null/empty이면 true  → 수동 추가 (O)
// hasText:       텍스트가 있으면 true  → 수동 추가 (X, localStorageKey가 있는데 수동?)
```

로컬에서는 이전 빌드 캐시로 통과했지만, CI의 clean build에서 테스트 실패.

**교훈: 유틸 메서드를 교체할 때 반환값의 의미가 반대인지 반드시 확인. `clean test`로 캐시 없이 돌리는 습관이 CI 실패를 예방한다.**

### 5-3. 통합테스트 vs 유닛테스트 — 언제 뭘 써야 하나

이번 세션에서 체감한 기준:

| 검증 대상 | 적합한 테스트 | 이유 |
|----------|-------------|------|
| 변경감지로 DB 반영 (`update`) | **통합** | 실제 flush/commit 없이는 확인 불가 |
| Cascade로 FK 세팅 여부 | **통합** | 영속성 컨텍스트 캐시가 마스킹함 |
| 분기 로직, mock 검증 (`create`) | 유닛 | DB 없이 빠르게 검증 가능 |
| 단순 삭제 (`deleteById`) | 통합 하나면 충분 | 유닛으로 `verify(repo).deleteById()` 해봤자 의미 약함 |

### 5-4. CI에서만 실패하는 또 다른 원인 — 커밋 누락

두 번째 PR CI 실패는 `LocationVoteResponse.java`가 스테이징만 되고 커밋이 안 된 상태로 push한 것이 원인. 로컬에는 파일이 있으니 빌드가 되지만, CI에서는 해당 클래스가 없어서 컴파일 에러.

**교훈: push 전에 `git status`로 커밋 안 된 파일이 있는지 확인하는 습관.**

---

## 6. API 설계 컨벤션 정리

### RESTful 원칙 — "어떤 리소스를" (URL) + "어떻게" (Body) 분리

```java
// 삭제: 대상만 식별
@DeleteMapping("/vote/{locationVoteId}")

// 수정: 대상 식별 + 변경 내용
@PutMapping("/vote/{locationVoteId}")
public void update(@PathVariable Long locationVoteId, @RequestBody UpdateLocationVoteRequest request)
```

Request Body에 ID를 담아 보내는 방식도 동작은 하지만, REST 원칙에서는 리소스 식별은 URL에, 데이터는 Body에 분리하는 것이 일반적.

### DTO 네이밍

- **Request**: 동사 접두사로 용도 구분 (`CreateLocationVoteRequest`, `UpdateLocationVoteRequest`)
- **Response**: 도메인명 + Response (`LocationVoteResponse`) — 조회/생성 응답 모두 재사용 가능. `FindLocationVoteResponse`처럼 동사를 붙이면 조회에만 한정됨.

### 위도/경도 타입

- **DTO**: String (JSON 부동소수점 정밀도 손실 방지, BigDecimal 직렬화 이슈 방지)
- **Entity**: BigDecimal(10, 7) (서비스/엔티티 레이어에서 `new BigDecimal()`로 변환)

Gemini 코드 리뷰에서 "DTO에서 BigDecimal로 받아라"는 제안이 있었지만, 위 근거를 들어 String 유지로 결론. Gemini도 납득.

### Validation

| 어노테이션 | null | `""` | `"   "` |
|-----------|------|------|---------|
| `@NotNull` | X | O | O |
| `@NotBlank` | X | X | X |

값이 반드시 있어야 하는 String 필드는 `@NotBlank`.

### JPA Repository에서 DTO 프로젝션

전체 필드를 DTO로 매핑하려면 JPQL `new` 연산자를 쓸 수 있지만, 전체 필드면 프로젝션의 이점(SELECT 최적화)이 없으므로 **엔티티 조회 → 서비스에서 DTO 변환** 패턴이 더 낫다.

```java
// Repository
List<LocationVote> findByLocationPoll_LocationPollId(Long locationPollId);

// Service
List<LocationVoteResponse> responses = locationVotes.stream()
        .map(LocationVoteResponse::from).toList();
```

---

## 7. JaCoCo 커버리지

```groovy
jacocoTestCoverageVerification {
    classDirectories → **/service/impl/** 만 대상
    rule {
        // element 미지정 → BUNDLE (전체 합산)
        limit { minimum = 0.70 }
    }
}
```

`element` 미지정 시 기본값 `BUNDLE`로, 대상 클래스들을 **모두 합산**하여 70% 이상이면 통과. `MeetingServiceImpl`이 64%여도 다른 ServiceImpl이 높으면 전체로 넘길 수 있다. 클래스별로 강제하려면 `element = 'CLASS'`.

---

## 8. 이번 세션 최종 구현 범위

| API | HTTP | 테스트 |
|-----|------|--------|
| 출발지 추가 | `POST /vote` | 유닛 4개 + 통합 4개 |
| 출발지 목록 조회 | `GET /vote` | - |
| 출발지 수정 | `PUT /vote/{id}` | 통합 1개 |
| 출발지 삭제 | `DELETE /vote/{id}` | 통합 1개 |
