# 2026-02-10 세션 정리: PR #69 리뷰 검토 + 엔드포인트 리팩토링

## 배경

모여락(Moyeolak)은 비회원 기반 모임 일정 조율 서비스입니다. 대표자가 모임을 만들고 링크를 공유하면, 참여자가 링크를 통해 이름을 입력하고 가능한/불가능한 시간을 선택해서 투표합니다. 로그인 없이 브라우저의 localStorage UUID로 사용자를 식별합니다.

PR #69는 시간 투표 수정 API(`updateScheduleVotes`)에 대한 구현이었고, Gemini Code Assist로 코드 리뷰를 받은 뒤 그 리뷰 내용을 직접 검토하는 것이 이번 세션의 시작점이었습니다.

---

## 1. Gemini 리뷰 검토: HashSet 최적화 제안

**Gemini의 지적:**
`updateScheduleVotes` 메서드에서 `isSelectingAvailable`이 false일 때, 전체 시간 슬롯(`allSlots`)을 스트리밍하면서 `request.votedDates().contains()`를 호출하고 있는데, `votedDates`가 List이므로 O(N*M) 시간 복잡도를 가진다. HashSet으로 변환하면 O(N+M)으로 개선 가능하다.

**검토 결과: 거절 (Premature Optimization)**

세 가지 근거로 반박했습니다:

1. **데이터 규모가 극히 작음** — 모임 일정 투표에서 `votedDates`와 `allSlots`는 현실적으로 수십 개 수준. N*M이 수백~수천 정도인 상황에서 HashSet 변환의 오버헤드(객체 생성, 해싱)가 오히려 더 클 수 있음.

2. **병목이 아님** — 이 메서드는 DB 조회(`findById`, `getSchedulePoll`)를 포함하고 있어서, `contains()` 호출은 전체 실행 시간에서 무시할 수 있는 비율. 네트워크/DB I/O가 수 ms인데 인메모리 리스트 순회는 수 μs 수준.

3. **가독성 우선** — 현재 코드가 더 간결하고 읽기 쉬움. `Set.copyOf(request.votedDates())`를 추가하면 한 줄이 더 생기고, "왜 Set으로 변환하지?"라는 의문을 유발.

**Gemini 응답:** 세 가지 근거 모두 타당하다며 동의. premature optimization 원칙에 따라 현재 코드 유지로 합의.

---

## 2. Gemini 리뷰 검토: SRP 위반 지적

**Gemini의 지적:**
`updateScheduleVotes` 메서드가 이름과 달리 참가자 이름(`participantName`)도 함께 수정하고 있다. 이는 단일 책임 원칙(SRP)에 위배될 수 있으며, 투표 수정과 참여자 정보 수정을 별도 API로 분리하거나 메서드 이름을 변경하는 것을 제안.

**검토 결과: API 분리 불필요, 메서드명은 개선 여지 있음**

- 이 서비스는 비회원 기반. 사용자가 투표 화면에 진입할 때 이름을 입력하고 투표 내용을 **한 번에** 제출한다. 프론트엔드 기준으로 "이름 입력 + 투표"가 하나의 사용자 액션.
- API를 2개로 쪼개면 프론트가 두 번 호출해야 하고, 하나만 실패했을 때 정합성 처리가 복잡해짐.
- SRP의 핵심은 "변경의 이유가 다른 것을 분리하라"인데, 여기서 이름과 투표는 항상 같이 변경되므로 변경의 이유가 같음.

**메서드명 논의:**
- `updateParticipantVote` → ScheduleController에 있으면 "이거 ParticipantController에 있어야 하는 거 아닌가?" 라는 혼란 발생
- 최종 결론: `updateScheduleVote`(단수형) — 기존 이름에서 `s`만 빼고 단수형으로. Schedule 도메인에 자연스럽고, Request DTO도 `UpdateScheduleVoteRequest`로 통일

---

## 3. 엔드포인트 도메인 소속 불일치 발견 → 리팩토링

기존 코드 구조를 분석하면서 근본적인 설계 문제를 발견했습니다.

**기존 구조:**
- 시간 투표 **생성**: `POST /api/participants/join-with-schedule` (ParticipantController)
- 시간 투표 **수정**: `PUT /api/schedules/vote/{scheduleVoteId}` (ScheduleController)

같은 "참가자 이름 + 시간 투표"를 다루는 기능인데 생성과 수정의 도메인 소속이 불일치. 사용자가 이 페이지에 오는 목적은 "시간 투표를 하러 온 것"이지 "참가자로 등록하러 온 것"이 아니므로, 기능의 메인은 시간 투표이고 참가자 생성은 부수적인 선행 조건.

**리팩토링 결정:**
- `join-with-schedule`을 ScheduleController로 이동
- `join-with-location`도 같은 패턴이므로 LocationController로 이동 (예정)
- ParticipantController에는 순수 조회 API만 남김

**새 엔드포인트 설계:**

| 동작 | Before | After |
|------|--------|-------|
| 시간투표 생성 | `POST /api/participants/join-with-schedule` | `POST /api/schedules/vote?meetingId={id}` |
| 시간투표 수정 | `PUT /api/schedules/vote/{scheduleVoteId}` | 유지 |
| 위치투표 생성 | `POST /api/participants/join-with-location` | `POST /api/locations/vote?meetingId={id}` (예정) |

**REST 관점 판단:**
- URL에 `participant`가 없어도 되는가? → OK. REST에서 URL은 생성/조작되는 **주 리소스**를 나타내면 됨. 참가자 정보(name, localStorageKey)는 "누가 투표하는지"를 식별하기 위한 request body의 메타데이터.
- 비유: `POST /api/orders`로 주문을 생성할 때 body에 고객 정보가 들어간다고 URL이 `/api/customers/orders`일 필요는 없음.
- `meetingId`는 PathVariable이 아닌 RequestParam — 리소스 식별자가 아니라 "어떤 모임에 대한 투표인지"를 지정하는 참조 파라미터.

---

## 4. Participant 도메인 독립성 검토

엔드포인트를 옮기면서 "그러면 ParticipantController에 남을 메인 기능이 뭐가 있는가?"를 고민했습니다.

**결론: 참가자만의 독립적인 기능은 거의 없음.**

- 현재 남는 건 조회 2개뿐 (`GET /api/participants`, `GET /api/participants/{id}`)
- 향후 가능: 참가자 삭제(모임 나가기), 본인 확인(localStorageKey 체크) 정도
- 이것도 투표 도메인에서 부수적으로 처리 가능한 수준

**근본 원인:** 이 서비스에서 Participant는 독립적인 도메인이라기보다 **투표의 주체를 식별하기 위한 보조 엔티티**. 로그인도 없고, 프로필도 없고, 참가자 자체로 할 수 있는 행위가 없음.

ParticipantController를 아예 없애고 조회를 MeetingController 등에 녹이는 것도 가능하지만, 현 단계에서는 조회용으로 유지하기로 결정.

---

## 5. Swagger 가독성 개선

ParticipantController의 기존 코드는 Swagger 어노테이션이 100줄 이상으로 비즈니스 로직 가독성을 심하게 저하시키고 있었습니다. 새로 만든 ScheduleController 엔드포인트에는 이 문제를 해결하기로 했습니다.

**검토한 방법 3가지:**
1. **커스텀 어노테이션** — Swagger 어노테이션들을 별도 어노테이션 클래스로 추출
2. **인터페이스 분리** — Controller 인터페이스에 Swagger 전담, 구현체는 비즈니스만
3. **최소화** — `@Operation` summary만 남기고 상세 예시 삭제

**1번 커스텀 어노테이션 채택 이유:**
- 3번은 프론트 협업 시 상세 예시 없으면 슬랙으로 물어보게 됨. 기존 문서를 버리는 셈.
- 2번은 Service 계층도 이미 interface/impl 구조라서 파일이 너무 많아짐 (하나의 기능에 파일 4개).
- 1번은 기존 Swagger 내용을 그대로 유지하면서 컨트롤러 가독성만 확보. 파일 하나 추가로 끝.

**적용 결과:**
- `domain/schedule/docs/CreateScheduleVoteApiDocs.java` 생성
- SpringDoc은 메타 어노테이션을 자동 인식하므로 별도 설정 불필요
- 컨트롤러에서는 `@CreateScheduleVoteApiDocs` 한 줄로 깔끔

---

## 6. 테스트 코드 작성 및 정리

**신규 테스트 (ScheduleServiceUnitTest - CreateParticipantVote):**
- 정상적으로 참가자와 시간 투표가 생성된다
- 중복 localStorageKey로 요청 시 예외가 발생한다
- 존재하지 않는 모임 ID로 요청 시 예외가 발생한다

**삭제한 테스트:**
- ParticipantServiceImplTest — createWithSchedule 관련 4개 (로직이 ScheduleService로 이동했으므로)
- ParticipantControllerTest — joinWithSchedule 관련 2개 (엔드포인트가 ScheduleController로 이동했으므로)

**테스트 작성 중 겪은 이슈:**
- `new BusinessException(null)` — ErrorCode에 null을 넣으면 NPE 발생. 실제 ErrorCode 값을 넣어야 함.
- `Meeting.ofId()`로 만든 객체에 `addPolls()` 누락 — `SchedulePoll.defaultOf(meeting)`은 SchedulePoll을 생성만 하고 Meeting의 schedulePoll 필드에 세팅하지 않음. `meeting.addPolls(schedulePoll, null)` 호출 필요.
- 비즈니스 로직 자체에는 문제 없었고, 테스트 셋업의 문제였음.

---

## 7. 코드 변경 내역 요약

### As-Is
- 시간 투표 생성 API(`POST /api/participants/join-with-schedule`)가 **ParticipantController**에 위치
- 시간 투표 수정 API(`PUT /api/schedules/vote/{id}`)는 **ScheduleController**에 위치
- 동일한 기능(참가자 이름 + 시간 투표)의 생성/수정이 **서로 다른 도메인 컨트롤러에 분산**되어 있어 일관성 부족
- Swagger 어노테이션이 컨트롤러 메서드에 직접 작성되어 비즈니스 로직 가독성 저하 (~110줄)

### To-Be
- 시간 투표 생성 API를 **ScheduleController**(`POST /api/schedules/vote`)로 이전하여 생성/수정 엔드포인트를 하나의 도메인에 통일
- 생성 로직을 **ScheduleServiceImpl.createParticipantVote()**로 이동, ParticipantController에서 기존 `joinWithSchedule` 메서드 및 관련 코드 제거
- Swagger 문서를 **커스텀 어노테이션**(`@CreateScheduleVoteApiDocs`)으로 분리하여 컨트롤러 가독성 확보
- 이동에 따른 테스트 코드 재배치: ScheduleServiceUnitTest에 생성 테스트 3개 추가, ParticipantServiceImplTest/ParticipantControllerTest에서 관련 테스트 6개 제거

**신규 생성:**
- `schedule/docs/CreateScheduleVoteApiDocs.java` — Swagger 커스텀 어노테이션
- `ScheduleServiceUnitTest` — createParticipantVote 테스트 3개 추가

**수정:**
- `ScheduleController` — createScheduleVote 엔드포인트에 커스텀 어노테이션 적용
- `ScheduleServiceUnitTest` — 기존 update 테스트는 유지, create 테스트 추가

**삭제:**
- `ParticipantController.joinWithSchedule()` 메서드 전체 (Swagger 포함 ~110줄)
- `ParticipantServiceImplTest` — createWithSchedule 관련 테스트 4개
- `ParticipantControllerTest` — joinWithSchedule 관련 테스트 2개

---

## 8. 미완료 / 후속 작업

- [ ] `join-with-location`도 LocationController로 이동 (같은 패턴 적용)
- [ ] `updateScheduleVote`에도 커스텀 어노테이션 적용
- [ ] ParticipantController 나머지 엔드포인트에도 커스텀 어노테이션 적용
- [ ] ParticipantService 인터페이스에서 `createWithSchedule` 메서드 시그니처 정리 (사용처 없으면 삭제)

---

## 포트폴리오 활용 포인트

1. **AI 리뷰를 맹목적으로 수용하지 않고 도메인 컨텍스트 기반으로 판단** — Gemini가 이론적으로 맞는 제안(HashSet 최적화, SRP 분리)을 했지만, 데이터 규모/병목 분석/사용자 플로우를 근거로 거절. Gemini도 동의.
2. **엔드포인트 도메인 소속 불일치 발견 → REST 원칙 기반 리팩토링** — 생성/수정이 다른 컨트롤러에 흩어진 문제를 발견하고, "기능의 메인이 뭔가?"를 기준으로 재배치.
3. **도메인 경계 고민** — "Participant가 정말 독립 도메인인가?" → 보조 엔티티라는 판단. 실무에서 테이블이 있다고 무조건 Controller/Service를 만드는 게 아니라, 비즈니스 행위 기준으로 경계를 잡아야 함.
4. **Swagger 가독성 vs 프론트 협업** — 트레이드오프를 분석하고 커스텀 어노테이션으로 양쪽 모두 해결.
